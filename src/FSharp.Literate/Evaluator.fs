namespace FSharp.Literate

open System
open System.IO
open FSharp.Markdown
open FSharp.CodeFormat

open Yaaf.FSharp.Scripting

// ------------------------------------------------------------------------------------------------
// Evaluator
// ------------------------------------------------------------------------------------------------

/// Represents a kind of thing that can be embedded 
[<RequireQualifiedAccessAttribute>]
type FsiEmbedKind = 
  | Output
  | ItValue
  | Value

/// An interface that represents FSI evaluation result
/// (we make this abstract so that evaluators can store other info)
type IFsiEvaluationResult = interface end

/// Represents the result of evaluating an F# snippet. This contains
/// the generated console output together with a result and its static type.
type FsiEvaluationResult = 
  { Output : string option
    ItValue : (obj * Type) option
    Result : (obj * Type) option }
  interface IFsiEvaluationResult

/// Record that is reported by the `EvaluationFailed` event when something
/// goes wrong during evalutaiton of an expression
type FsiEvaluationFailedInfo = 
  { Text : string
    AsExpression : bool
    File : string option
    Exception : exn
    StdErr : string }
    override x.ToString() =
      let indent (s:string) = 
        s.Split([| '\n'; '\r' |], StringSplitOptions.RemoveEmptyEntries)
        |> Array.map(fun x -> "    " + x)
        |> fun x -> String.Join("\n", x)
      sprintf "Error evaluating expression \nExpression:\n%s\nError:\n%s" (indent x.Text) (indent x.StdErr)

/// Represents an evaluator for F# snippets embedded in code
type IFsiEvaluator =
  /// Called to format some part of evaluation result generated by FSI
  abstract Format : IFsiEvaluationResult * FsiEmbedKind -> MarkdownParagraphs
  /// Called to evaluate a snippet 
  abstract Evaluate : string * asExpression:bool * file:string option -> IFsiEvaluationResult

/// A wrapper for F# interactive service that is used to evaluate inline snippets
type FsiEvaluator(?options:string[]) =
  // Initialize F# Interactive evaluation session

  let fsiOptions = match options with
                   | Some opts -> FsiOptions.ofArgs opts
                   | None -> FsiOptions.Default
  let fsiSession = ScriptHost.Create(fsiOptions, preventStdOut = true)

  let evalFailed = new Event<_>()
  let lockObj = obj()

  /// Registered transformations for pretty printing values
  /// (the default formats value as a string and emits single CodeBlock)
  let mutable valueTransformations = 
    [ (fun (o:obj, t:Type) ->Some([CodeBlock (sprintf "%A" o, "", "")]) ) ]

  /// Register a function that formats (some) values that are produced by the evaluator.
  /// The specified function should return 'Some' when it knows how to format a value
  /// and it should return formatted 
  member x.RegisterTransformation(f) =
    valueTransformations <- f::valueTransformations

  /// This event is fired whenever an evaluation of an expression fails
  member x.EvaluationFailed = evalFailed.Publish

  interface IFsiEvaluator with
    /// Format a specified result or value 
    member x.Format(result, kind) =
      if not (result :? FsiEvaluationResult) then 
        invalidArg "result" "FsiEvaluator.Format: Expected 'FsiEvaluationResult' value as argument."
      match result :?> FsiEvaluationResult, kind with
      | result, FsiEmbedKind.Output -> 
          let s = defaultArg result.Output "No output has been produced."
          [ CodeBlock(s.Trim(), "", "") ]
      | { ItValue = Some v }, FsiEmbedKind.ItValue
      | { Result = Some v }, FsiEmbedKind.Value ->
          valueTransformations |> Seq.pick (fun f -> lock lockObj (fun () -> f v))
      | _, FsiEmbedKind.ItValue -> [ CodeBlock ("No value has been returned", "", "") ]
      | _, FsiEmbedKind.Value -> [ CodeBlock ("No value has been returned", "", "") ]

    /// Evaluates the given text in an fsi session and returns
    /// an FsiEvaluationResult.
    ///
    /// If evaluated as an expression, Result should be set with the
    /// result of evaluating the text as an F# expression.
    /// If not, just the console output of the evaluation is captured and
    /// returned in Output.
    ///
    /// If file is set, the text will be evaluated as if it was present in the
    /// given script file - this is for correct usage of #I and #r with relative paths.
    /// Note however that __SOURCE_DIRECTORY___ does not currently pick this up.
    member x.Evaluate(text:string, asExpression, ?file) =
      try
        lock lockObj <| fun () ->
          let dir = match file with
                    | Some f -> Path.GetDirectoryName f
                    | None -> Directory.GetCurrentDirectory()
          fsiSession.WithCurrentDirectory dir (fun () ->
            let (output, value), itvalue =
              if asExpression then
                fsiSession.TryEvalExpressionWithOutput text, None
              else
                let output = fsiSession.EvalInteractionWithOutput text
                // try get the "it" value, but silently ignore any errors
                try
                  (output, None), fsiSession.TryEvalExpression "it"
                with _ -> (output, None), None
            { Output = Some output.Output.ScriptOutput; Result = value; ItValue = itvalue  } :> _
          )
      with :? FsiEvaluationException as e ->
        evalFailed.Trigger { File=file; AsExpression=asExpression; Text=text; Exception=e; StdErr = e.Result.Error.Merged }
        { Output = None; Result = None; ItValue = None } :> _
